---
title: Authentication
description: API keys, SSO, OIDC, SAML, JWT, and reverse proxy authentication for the gateway and web UI
---

import { Callout } from "fumadocs-ui/components/callout";

Hadrian authenticates two independent contexts — **gateway** (API) and **admin** (UI) — each configured separately in `hadrian.toml`.

## Two Auth Contexts

| Context     | Config Section   | Protects                                                       | Used by                       |
| ----------- | ---------------- | -------------------------------------------------------------- | ----------------------------- |
| **Gateway** | `[auth.gateway]` | `/v1/*` endpoints (chat completions, embeddings, models, etc.) | SDKs, curl, the chat UI       |
| **Admin**   | `[auth.admin]`   | `/admin/*` endpoints and the web UI login                      | Browser sessions, admin tools |

These are fully independent. A request to `/v1/chat/completions` only checks gateway auth. A request to `/admin/v1/users` only checks admin auth. The web UI uses **both** — admin auth for login, then either a session cookie or an API key for gateway calls depending on the configuration.

### Gateway Auth Types

| Type       | How it works                                                                                                                    |
| ---------- | ------------------------------------------------------------------------------------------------------------------------------- |
| `none`     | No credentials required. Requests proceed as an anonymous user. Never use in production.                                        |
| `api_key`  | Validate API keys created via the Admin UI or API. Keys are sent via `X-API-Key` or `Authorization: Bearer` header.             |
| `jwt`      | Validate JWT tokens signed by an identity provider. Requires JWKS URL for signature verification.                               |
| `multi`    | Accept **both** API keys and JWTs. Format-based detection: tokens starting with the key prefix (e.g. `gw_`) are treated as API keys, everything else as JWTs. |

### Admin Auth Types

| Type         | How it works                                                                                                                                                 |
| ------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| `none`       | No login required. The admin panel and all admin API endpoints are completely unprotected. Only safe on localhost or trusted private networks.                |
| `oidc`       | Single global OIDC provider. Users log in via browser redirect. A session cookie is set that also authenticates `/v1/*` requests — no API key needed.         |
| `session`    | Per-organization SSO. Each org configures their own OIDC or SAML provider via the Admin UI. Session cookies authenticate both admin and gateway requests.     |
| `proxy_auth` | Trust identity headers from a reverse proxy (Cloudflare Access, Tailscale, oauth2-proxy). Only authenticates admin routes — gateway requires separate auth.  |

<Callout type="info">
  With `oidc` or `session` admin auth, the session cookie authenticates **both** `/admin/*` and `/v1/*`
  requests. Users log in once and the chat UI works immediately — no API key needed.
  With `none` or `proxy_auth`, the chat UI requires an API key created through the admin panel.
</Callout>

## Deployment Scenarios

Pick the scenario closest to your deployment. Each includes a minimal working config.

| #   | Scenario                                                            | Gateway        | Admin        | Web UI experience                                               | SDK / API access          |
| --- | ------------------------------------------------------------------- | -------------- | ------------ | --------------------------------------------------------------- | ------------------------- |
| 1   | [Local development](#1-local-development)                           | `none`         | `none`       | No login, everything open                                       | No credentials needed     |
| 2   | [Single-user / internal tool](#2-single-user--internal-tool)        | `api_key`      | `none`       | No login; create an API key in admin panel, paste into settings  | API key                   |
| 3   | [Production API with single IdP](#3-production-api-with-single-idp) | `jwt`          | `oidc`       | OIDC login, session cookie handles everything                   | JWT from IdP              |
| 4   | [API keys + SSO admin UI](#4-api-keys--sso-admin-ui)                | `api_key`      | `session`    | Per-org SSO login; create API key for chat                      | API key                   |
| 5   | [Combined API keys + JWT](#5-combined-api-keys--jwt-single-idp)     | `multi`        | `oidc`       | OIDC login, session cookie handles everything                   | API key or JWT            |
| 6   | [Multi-org, per-org IdP](#6-multi-org-each-org-with-own-idp)        | `multi`        | `session`    | Per-org SSO login, session cookie handles everything            | API key or per-org JWT    |
| 7   | [Zero-trust / reverse proxy](#7-zero-trust--reverse-proxy)          | `api_key`      | `proxy_auth` | Proxy handles login; create API key for chat                    | API key                   |

---

### 1. Local development

No authentication. All requests proceed anonymously. The admin panel, chat UI, and API are all open.

```toml
[auth.gateway]
type = "none"

[auth.admin]
type = "none"
```

<Callout type="warn">
  Never use `type = "none"` in production. Requests are unauthenticated and usage cannot be
  attributed to users.
</Callout>

### 2. Single-user / internal tool

API keys for programmatic access, no admin login required. The admin panel is unprotected — anyone with network access can create API keys, users, and organizations.

```toml
[auth.gateway]
type = "api_key"
key_prefix = "gw_"
cache_ttl_secs = 300

[auth.admin]
type = "none"
```

**Getting started:** Open the admin panel, create an API key, then use it with the OpenAI SDK or paste it into the chat UI settings.

<Callout type="warn">
  The admin panel has no authentication in this scenario. Only use this on private networks
  where you trust all users with admin access.
</Callout>

### 3. Production API with single IdP

JWT tokens from your identity provider for API access, OIDC login for the web UI. Users log in once via OIDC and the session cookie authenticates both the admin panel and chat UI — no API key needed.

```toml
[auth.gateway]
type = "jwt"
issuer = "https://auth.example.com"
audience = "hadrian"
jwks_url = "https://auth.example.com/.well-known/jwks.json"

[auth.admin]
type = "oidc"
issuer = "https://auth.example.com"
client_id = "hadrian"
client_secret = "${OIDC_CLIENT_SECRET}"
redirect_uri = "https://gateway.example.com/auth/callback"

[auth.admin.provisioning]
enabled = true
create_users = true
organization_id = "acme-corp"
```

**Getting started:** Configure your IdP (Okta, Auth0, Keycloak, etc.) with Hadrian as a client. Users are auto-provisioned on first login via JIT provisioning.

### 4. API keys + SSO admin UI

API keys for programmatic access, per-org SSO for the admin panel. Each organization configures their own OIDC or SAML provider through the Admin UI at runtime.

```toml
[auth.gateway]
type = "api_key"
key_prefix = "gw_"
cache_ttl_secs = 300

[auth.admin]
type = "session"
secret = "${SESSION_SECRET}"
```

**Getting started:** Use the [bootstrap API key](/docs/configuration/auth#bootstrap-configuration) to create the initial organization and SSO config, then org admins log in via SSO and create API keys for their teams. See the [SSO Admin Guide](/docs/features/sso-admin-guide).

<Callout type="info">
  Since gateway auth is `api_key` only, the chat UI requires users to create an API key in the admin
  panel and paste it into settings. For a seamless chat experience without API keys, use scenario 5 or 6.
</Callout>

### 5. Combined API keys + JWT (single IdP)

Support both API keys and JWT tokens on `/v1/*` endpoints. The gateway uses format-based detection to distinguish them. Users log in via OIDC and the session cookie handles the chat UI automatically.

```toml
[auth.gateway]
type = "multi"

[auth.gateway.api_key]
key_prefix = "gw_"
cache_ttl_secs = 300

[auth.gateway.jwt]
issuer = "https://auth.example.com"
audience = "hadrian"
jwks_url = "https://auth.example.com/.well-known/jwks.json"

[auth.admin]
type = "oidc"
issuer = "https://auth.example.com"
client_id = "hadrian"
client_secret = "${OIDC_CLIENT_SECRET}"
redirect_uri = "https://gateway.example.com/auth/callback"
```

**Getting started:** Same as scenario 3. Additionally, create API keys via the admin panel for CI pipelines, scripts, or OpenAI SDK clients that can't use browser-based OIDC.

### 6. Multi-org, each org with own IdP

Each organization brings their own identity provider. `[auth.gateway.jwt]` is **not needed** in the config — per-org SSO configs automatically provide JWT validation on API endpoints.

```toml
[auth.gateway]
type = "multi"

[auth.gateway.api_key]
key_prefix = "gw_"
cache_ttl_secs = 300

# No [auth.gateway.jwt] section needed.
# Per-org SSO configs provide JWT validation automatically.

[auth.admin]
type = "session"
secret = "${SESSION_SECRET}"

[auth.bootstrap]
api_key = "${HADRIAN_BOOTSTRAP_KEY}"
auto_verify_domains = ["acme.com"]
```

When a JWT arrives on `/v1/*`, the gateway decodes the `iss` claim and looks up the matching per-org SSO config. See [Per-Org JWT Routing](#per-org-jwt-routing) for details.

**Getting started:** Use the [bootstrap API key](/docs/configuration/auth#bootstrap-configuration) to create organizations. Each org admin then configures their IdP via the [SSO Admin Guide](/docs/features/sso-admin-guide). Users are auto-provisioned on first SSO login.

### 7. Zero-trust / reverse proxy

Trust identity headers from an authenticating reverse proxy (Cloudflare Access, Tailscale, oauth2-proxy, etc.). The proxy authenticates all admin panel access automatically.

```toml
[server.trusted_proxies]
cidrs = ["173.245.48.0/20", "103.21.244.0/22"]

[auth.gateway]
type = "api_key"
key_prefix = "gw_"

[auth.admin]
type = "proxy_auth"
identity_header = "Cf-Access-Authenticated-User-Email"
email_header = "Cf-Access-Authenticated-User-Email"
```

**Getting started:** The proxy handles admin panel authentication. Create API keys via the admin panel for chat UI and SDK access.

<Callout type="error">
  Always configure `[server.trusted_proxies]` to prevent header spoofing. Without this, attackers
  can forge identity headers.
</Callout>

<Callout type="info">
  Proxy auth only covers the admin panel. The chat UI requires an API key because
  `/v1/*` uses `api_key` auth, which the proxy headers don't satisfy.
</Callout>

## Architecture

```mermaid
flowchart TD
    subgraph Clients
        SDK[SDK / API Clients<br/><i>OpenAI SDK, etc.</i>]
        Browser[Browser / Web UI]
    end

    subgraph API_Auth["API Authentication"]
        A1[API Keys]
        A2[JWT Tokens<br/><i>global or per-org</i>]
        A3[Multi-Auth]
    end

    subgraph UI_Auth["UI Authentication"]
        U2[Reverse Proxy - Cloudflare, etc.]
        subgraph U3["Session — Per-Org SSO"]
            U1[OIDC - Okta, Keycloak...]
            U4[SAML 2.0 - AD FS, Azure AD...]
        end
    end

    AuthZ[Authorization<br/><b>CEL-based RBAC</b>]

    SDK --> API_Auth
    Browser --> UI_Auth
    API_Auth --> AuthZ
    UI_Auth --> AuthZ
    U3 -.->|per-org JWT<br/>validation| A2

```

### Default Behavior (No Auth)

By default, both `auth.gateway` and `auth.admin` are set to `type = "none"`, which allows anonymous access. When both are disabled:

- **API requests** proceed without credentials. A default anonymous user and organization are created for usage tracking.
- **Admin routes** are unprotected — the web UI works without login.
- **RBAC is permissive** — all authorization checks pass automatically.

#### Credential Handling in No-Auth Mode

Even when authentication is disabled, the gateway validates credentials that are explicitly provided:

| Scenario                                                    | Result                                     |
| ----------------------------------------------------------- | ------------------------------------------ |
| No credentials sent                                         | Request proceeds as anonymous              |
| Valid credentials sent                                      | Request proceeds as the authenticated user |
| Invalid credentials sent (expired JWT, wrong API key, etc.) | **401 Rejected**                           |

This means you can incrementally adopt authentication — existing anonymous clients continue working while authenticated clients get identity tracking and RBAC. However, clients must not send placeholder or invalid credentials.

## Gateway Authentication

Gateway authentication secures programmatic access to `/v1/*` endpoints (chat completions, embeddings, etc.).

### API Keys

The most common method for API access. Keys are created via the Admin UI or API and validated against the database.

```bash
# Using X-API-Key header
curl -H "X-API-Key: gw_live_abc123..." \
  https://gateway.example.com/v1/chat/completions

# Using Authorization header (OpenAI-compatible)
curl -H "Authorization: Bearer gw_live_abc123..." \
  https://gateway.example.com/v1/chat/completions
```

**Key features:**

- Configurable prefix (`gw_live_`, `gw_test_`, etc.)
- Budget limits (daily/monthly caps)
- Expiration dates
- Usage tracking per key
- Owner binding (org, team, project, or user)

### JWT Tokens

Validate JWTs signed by an identity provider for service-to-service authentication.

```bash
curl -H "Authorization: Bearer eyJhbGciOiJSUzI1NiIs..." \
  https://gateway.example.com/v1/chat/completions
```

**Capabilities:**

- JWKS-based signature verification
- Configurable issuer and audience validation
- Custom claim extraction for RBAC
- Algorithm allowlisting (RS256, ES256, EdDSA, etc.)

### Multi-Auth

Support both API keys and JWT tokens simultaneously. The gateway uses format-based detection:

- **`X-API-Key` header**: Always validated as an API key
- **`Authorization: Bearer` header**: Tokens starting with the API key prefix (default `gw_`) are validated as API keys; all others are validated as JWTs

### Per-Org JWT Routing

In multi-tenant deployments where each organization has their own identity provider, incoming JWTs are routed to the correct per-org validator automatically:

1. **Decode `iss` claim** — Extract the issuer from the JWT (without verifying the signature yet)
2. **Per-org registry lookup** — Search the `GatewayJwtRegistry` for validators matching that issuer
3. **Lazy-load from DB** — On cache miss, query the database for enabled OIDC SSO configs with that issuer, perform OIDC discovery to fetch the JWKS URI, and build a validator
4. **Fall back to global** — If no per-org config matches and `[auth.gateway.jwt]` is configured, try the global validator
5. **Validate** — Verify the signature, expiry, audience, and issuer against the matched validator

**Key behaviors:**

- Validators are cached across requests — JWKS keys are not re-fetched per request
- Unknown issuers are negatively cached for 60 seconds to prevent DB query amplification
- When an SSO config is created or updated via the Admin API, the registry is updated immediately
- Multiple organizations can share the same issuer (each gets its own validator with its own audience)

<Callout type="info">
  Per-org JWT routing requires `[auth.gateway]` to be `type = "multi"` or `type = "jwt"`. When using
  `type = "multi"` without a `[auth.gateway.jwt]` section, only per-org SSO configs provide JWT
  validation — there is no global fallback.
</Callout>

<Cards>
  <Card title="Gateway Auth Configuration" href="/docs/configuration/auth#gateway-authentication" />
</Cards>

## Admin Authentication

Admin authentication secures browser sessions for the web interface.

### OIDC / SSO

Full OpenID Connect flow with browser redirects. Works with any OIDC-compliant identity provider:

| Provider            | Notes                                     |
| ------------------- | ----------------------------------------- |
| Okta                | Enterprise SSO with MFA                   |
| Auth0               | Developer-friendly with many integrations |
| Keycloak            | Self-hosted, open source                  |
| Azure AD / Entra ID | Microsoft 365 integration                 |
| Google Workspace    | Google account authentication             |
| OneLogin            | Enterprise identity management            |

**Capabilities:**

- Automatic user provisioning (JIT)
- Group-to-team mapping
- Configurable claims extraction
- Session management

### SAML 2.0

SAML 2.0 authentication for enterprise identity providers that require the Security Assertion Markup Language protocol:

| Provider            | Notes                             |
| ------------------- | --------------------------------- |
| AD FS               | Windows Server Active Directory   |
| Azure AD / Entra ID | Enterprise SAML application       |
| Okta                | Native SAML application templates |
| Keycloak            | Self-hosted, open source          |
| PingFederate        | Enterprise identity federation    |

**Capabilities:**

- XML digital signature verification
- Configurable attribute mappings
- SP metadata auto-generation
- Works with legacy IdPs that only support SAML

<Cards>
  <Card title="SAML Admin Guide" href="/docs/features/saml" />
</Cards>

### Per-Organization SSO

In multi-tenant deployments, each organization can configure their own identity provider. This enables:

- **Self-service SSO setup** - Org admins configure their own IdP via the Admin UI
- **Domain verification** - Prove domain ownership before enabling SSO
- **Enforcement modes** - Optional, test, or required SSO
- **Email-based IdP discovery** - Users enter email, redirected to correct IdP
- **Automatic API authentication** - Per-org SSO configs also enable JWT validation on `/v1/*` endpoints (see [Per-Org JWT Routing](#per-org-jwt-routing))

<Callout type="info">
  Per-organization SSO is configured through the Admin UI, not the gateway config file. See the [SSO
  Admin Guide](/docs/features/sso-admin-guide) for setup instructions.
</Callout>

### Reverse Proxy Auth

Trust identity headers from an authenticating reverse proxy:

| Service              | Headers                                 |
| -------------------- | --------------------------------------- |
| Cloudflare Access    | `Cf-Access-Authenticated-User-Email`    |
| oauth2-proxy         | `X-Forwarded-User`, `X-Forwarded-Email` |
| Tailscale            | `Tailscale-User-Login`                  |
| Authelia / Authentik | `Remote-User`, `Remote-Groups`          |
| Pomerium             | `X-Pomerium-Claim-Email`                |

<Callout type="error">
  Always configure trusted proxies to prevent header spoofing. Without this, attackers can forge
  identity headers.
</Callout>

<Cards>
  <Card title="Admin Auth Configuration" href="/docs/configuration/auth#admin-authentication" />
  <Card title="SSO Admin Guide" href="/docs/features/sso-admin-guide" />
</Cards>

## Just-in-Time Provisioning

Automatically create users and add them to organizations when they first authenticate via SSO.

**How it works:**

1. User authenticates via OIDC
2. Gateway checks if user exists in database
3. If not, creates user with attributes from ID token
4. Adds user to configured organization with default role
5. Optionally adds user to a default team

**Capabilities:**

- Create users on first login
- Assign to organization and team
- Map IdP groups to teams (SSO group mappings)
- Sync attributes on subsequent logins
- Restrict by email domain

<Callout type="info">
  JIT provisioning creates users on first login. For real-time provisioning and deprovisioning
  (required for SOC 2/HIPAA compliance), see [SCIM Provisioning](/docs/features/scim).
</Callout>

<Cards>
  <Card title="JIT Configuration" href="/docs/configuration/auth#jit-just-in-time-provisioning" />
  <Card title="SCIM Provisioning" href="/docs/features/scim" />
</Cards>

## SSO Group Mappings

Map identity provider groups to Hadrian teams for automatic team assignment during provisioning.

| IdP Group         | Team       | Role     | Priority |
| ----------------- | ---------- | -------- | -------- |
| `Engineers`       | `platform` | `member` | 0        |
| `SeniorEngineers` | `platform` | `lead`   | 10       |
| `PlatformAdmins`  | `platform` | `admin`  | 20       |

When a user belongs to multiple groups mapping to the same team, the highest priority determines the role.

<Cards>
  <Card title="Group Mappings Configuration" href="/docs/configuration/auth#sso-group-mappings" />
  <Card title="SSO Admin Guide" href="/docs/features/sso-admin-guide#sso-group-mappings" />
</Cards>

## Authorization (RBAC)

After authentication, authorization determines what users can access. Hadrian uses CEL (Common Expression Language) for fine-grained access control.

**Example policies:**

```toml
# Super admins have full access
[[auth.rbac.policies]]
name = "super-admin"
condition = "'super_admin' in subject.roles"
effect = "allow"
priority = 100

# Users can only access resources in their organization
[[auth.rbac.policies]]
name = "org-isolation"
condition = "context.org_id in subject.org_ids"
effect = "allow"
priority = 10
```

**API authorization** extends CEL policies to `/v1/*` endpoints for:

- Model access control (restrict GPT-4 to premium users)
- Token limits by tier
- Feature gating (tools, file search, reasoning)
- Time-based access (business hours only)

<Cards>
  <Card title="Authorization Guide" href="/docs/features/authorization" />
  <Card title="RBAC Configuration" href="/docs/configuration/auth#rbac-configuration" />
</Cards>

## Related Topics

<Cards>
  <Card title="Auth Configuration Reference" href="/docs/configuration/auth" />
  <Card title="SSO Admin Guide" href="/docs/features/sso-admin-guide" />
  <Card title="SAML Admin Guide" href="/docs/features/saml" />
  <Card title="SCIM Provisioning" href="/docs/features/scim" />
  <Card title="Authorization" href="/docs/features/authorization" />
  <Card title="Multi-Tenancy" href="/docs/features/multi-tenancy" />
</Cards>
